using {{CqrsNamespace}}.{{#Entity}}{{NamePlural}}{{/Entity}}.Commands;
using Application.Common.Exceptions;
using {{EntityNamespace}};
using Shared.Constants;

namespace {{TestNamespace}}.{{#Entity}}{{NamePlural}}{{/Entity}}.Commands;

{{#Entity}}
public class Delete{{Name}}CommandTest : MockWriteRepositoryTestBase<{{Name}}>
{
    private readonly Delete{{Name}}CommandHandler _handler;

    public Delete{{Name}}CommandTest()
    {
        _handler = new Delete{{Name}}CommandHandler(unitOfWork);
    }

    [Fact]
    public async Task ShouldDelete()
    {
{{#EntityFields}}
        {{{Mock}}}
{{/EntityFields}}

        await repository.InsertAsync(new {{Name}}
        {
{{ParamInitNonObject}}
        });
        await unitOfWork.SaveChangesAsync();

        int id = await repository.GetFirstOrDefaultAsync(predicate: s => s.{{FieldToCheckCreate}} == {{VarToCheckCreate}}, selector: s => s.Id);

        var command = new Delete{{Name}}Command { Id = id };
        var response = await _handler.Handle(command, CancellationToken.None);

        response.Message.Should().Be(MessageCommon.DeleteSuccess);
        (await repository.GetFirstOrDefaultAsync(predicate: s => s.{{FieldToCheckCreate}} == {{VarToCheckCreate}}))
            .Should()
            .BeNull();
    }

    [Fact]
    public async Task ShouldThrowNotFoundException()
    {
        var command = new Delete{{Name}}Command { Id = 99 };
        int itemsCount = await CountAsync();

        await Assert.ThrowsAsync<NotFoundException>(() => _handler.Handle(command, CancellationToken.None));
        (await CountAsync()).Should().Be(itemsCount);
    }
}{{/Entity}}