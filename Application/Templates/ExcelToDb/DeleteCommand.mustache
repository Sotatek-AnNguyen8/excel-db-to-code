using Application.Common.Exceptions;
using Application.Common.Responses;
using Application.Common.Repositories;
using Application.Common.UnitOfWork;
using {{EntityNamespace}};
using FluentValidation;
using MediatR;
using Shared.Constants;

namespace {{CqrsNamespace}}.{{#Entity}}{{NamePlural}}{{/Entity}}.Commands;

{{#Entity}}
public class Delete{{Name}}Command : IRequest<ResponseBase<IEnumerable<{{IdType}}>>>
{
    public List<{{IdType}}> Ids { get; init; } = new();
}

public class Delete{{Name}}CommandValidator : AbstractValidator<Delete{{Name}}Command>
{
    public Delete{{Name}}CommandValidator()
    {
        RuleFor(c => c.Ids)
            .NotEmpty();
        RuleForEach(c => c.Ids)
            .GreaterThan(0)
            .NotEmpty();
    }
}

public class Delete{{Name}}CommandHandler(IUnitOfWork unitOfWork) 
    : IRequestHandler<Delete{{Name}}Command, ResponseBase<IEnumerable<{{IdType}}>>>
{
    private readonly IWriteRepository<{{Name}}> _{{VarName}}Repository = unitOfWork.GetRepository<{{Name}}>();

    public async Task<ResponseBase<IEnumerable<{{IdType}}>>> Handle(
        Delete{{Name}}Command request, CancellationToken cancellationToken)
    {
        var toDelete{{NamePlural}} = await _{{VarName}}Repository.GetAllAsync(
            predicate: a => request.Ids.Contains(a.Id),
            disableTracking: false);

        _{{VarName}}Repository.Delete(toDelete{{NamePlural}});
        await unitOfWork.SaveChangesAsync();

        return new ResponseBase<IEnumerable<{{IdType}}>>(toDelete{{NamePlural}}.Select(a => a.Id), MessageCommon.DeleteSuccess);
    }
}{{/Entity}}